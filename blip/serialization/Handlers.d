module blip.serialization.Handlers;
import tango.core.Tuple;
import tango.io.protocol.Writer;
import tango.io.protocol.Reader;
import tango.io.stream.Format;
import tango.text.json.JsonEscape: escape;
import tango.io.encode.Base64: encode,decode;
import tango.core.Variant;
import blip.text.TextParser;

/// the non array core types
template isBasicCoreType(T){
    const bool isBasicCoreType=is(T==bool)||is(T==byte)||is(T==ubyte)||is(T==short)
     ||is(T==ushort)||is(T==int)||is(T==uint)||is(T==float)
     ||is(T==long)||is(T==ulong)||is(T==double)||is(T==real)
     ||is(T==ifloat)||is(T==idouble)||is(T==ireal)||is(T==cfloat)
     ||is(T==cdouble)||is(T==creal)||is(T==char[])||is(T==wchar[]);
}
/// the basic types, out of these more complex types are built
template isCoreType(T){
    const bool isCoreType=is(T==bool)||is(T==byte)||is(T==ubyte)||is(T==short)
     ||is(T==ushort)||is(T==int)||is(T==uint)||is(T==float)
     ||is(T==long)||is(T==ulong)||is(T==double)||is(T==real)
     ||is(T==ifloat)||is(T==idouble)||is(T==ireal)||is(T==cfloat)
     ||is(T==cdouble)||is(T==creal)||is(T==char[])||is(T==wchar[])
     ||is(T==dchar[])||is(T==ubyte[]);
}

alias Tuple!(bool,byte,ubyte,short,ushort,int,uint,long,ulong,
    float,double,real,ifloat,idouble,ireal,cfloat,cdouble,creal,ubyte[],
    char[],wchar[],dchar[]) CoreTypes;
alias Tuple!(char[],wchar[],dchar[]) CoreStringTypes;

/// string suitable to build names for the core type T
template strForCoreType(T){
    static if (is(T S:S[])){
        static if (is(T==ubyte[])){
            const char[]strForCoreType="binaryBlob";
        } else {
            const char[]strForCoreType=S.stringof~"Str";
        }
    } else{
        const char[]strForCoreType=T.stringof;
    }
}

/// generates a delegate for each type, this can be used to buid a kind of VTable
/// and hide the use of templates
char[] coreTypeDelegates(char[] indent="    "){
    char[] res="".dup;
    foreach (T;CoreTypes){
        res~=indent~"void delegate(ref "~T.stringof~" el) coreHandler_"~strForCoreType!(T)~";\n";
    }
    return res;
}

/// transfers all template implementations to the "V-table"
char[] coreHandlerSetFromTemplateMixinStr(char[] templateCall, char[] templateStr=null, char[] indent="    "){
    char[] res="".dup;
    if (templateStr is null) templateStr=templateCall;
    res~=indent~"void setCoreHandlersFrom_"~templateStr~"(){\n";
    foreach (T;CoreTypes){
        res~=indent~"    coreHandler_"~strForCoreType!(T)~"= &("~templateCall~"!("~T.stringof~"));\n";
    }
    res~=indent~"}\n";
    return res;
}

/// class to have dynamic dispatching of methods generated by templates
/// basically this is a V-table that can be initialized from a template
/// this trick removes the template dependence
class CoreHandlers{
    this(){}
    
    mixin(coreTypeDelegates());

    void handle(T)(ref T t){
        static assert(isCoreType!(T),T.stringof~" is not a core type");
        mixin("coreHandler_"~strForCoreType!(T)~"(t);");
    }
}

/// handlers for writing
class WriteHandlers: CoreHandlers{
    this(){}
    /// returns if the current protocol is binary or not
    bool binary(){
        assert(0,"unimplemented");
        return true;
    }
    /// writes a raw sequence of bytes
    void rawWrite(ubyte[] data){
        assert(0,"unimplemented");
    }
    /// writes a raw string
    void rawWriteStr(char[]data){
        assert(0,"unimplemented");
    }
}

/// handlers for reading
class ReadHandlers: CoreHandlers{
    this(){}
    /// returns if the current protocol is binary or not
    bool binary(){
        assert(0,"unimplemented");
        return false;
    }
    /// reads a raw sequence of bytes
    ubyte[] rawRead(size_t amount){
        assert(0,"unimplemented");
    }
    /// reads a raw string
    char[] rawReadStr(size_t amount){
        assert(0,"unimplemented");
    }
/+    /// reads the start of an array
    PosCounter readArrayStart(){
        return PosCounter(size_t.max);
    }
    /// tries to go to the next element of the array
    /// returns false if there is no next element (the array is finished)
    bool arrayNext(ref PosCounter ac,lazy void delegate() readEl) {
        return false;
    }
    /// start of a dictionary
    PosCounter readDictStart() {
        return PosCounter(size_t.max);
    }
    /// returns true if there is a next entry
    bool nextEntry(ref PosCounter, lazy void delegate() readKey,lazy void delegate() readVal) {
        return false;
    }
    /// read an Object
    /// read ObjectProxy
    /// read Struct
    /// read core type
    +/
}

/// write handlers build on the top of tango Writer (could be faster)
class BinaryWriteHandlers:WriteHandlers{
    protected Writer       writer_;
    
    this (Writer writer)
    {
        writer_=writer;
        setCoreHandlersFrom_basicWrite();
    }
    /+ /// guartees the given alignment
    void alignStream(int i){
        assert(i>0&&i<=32);
        if (i==1) return;
        auto pos=writer.seek(0,Anchor.Current);
        if (pos==Eof) return;
        auto rest=pos & (~((~0)<<i));
        if (rest==0) return;
        ubyte u=0;
        for (int j=(1<<(i-1))-rest;j!=0;--j)
            writer.handle(u);
    }+/

    Writer writer ()
    {
        return writer_;
    }
    
    void basicWrite(T)(ref T t){
        static if (is(T==ifloat)){
            writer_(t.im);
        } else static if (is(T==idouble)){
            writer_(t.im);
        } else static if (is(T==ireal)){
            writer_(t.im);
        } else static if (is(T==cfloat)){
            writer_(t.re);
            writer_(t.im);
        } else static if (is(T==cdouble)){
            writer_(t.re);
            writer_(t.im);
        } else static if (is(T==creal)){
            writer_(t.re);
            writer_(t.im);
        } else {
            writer_(t);
        }
    }
    
    mixin(coreHandlerSetFromTemplateMixinStr("basicWrite"));
    
    /// returns if the current protocol is binary or not
    bool binary(){
        return true;
    }
    /// writes a raw sequence of bytes
    void rawWrite(ubyte[] data){
        basicWrite(data);
    }
    /// writes a raw string
    void rawWriteStr(char[]data){
        basicWrite(data);
    }
/+    override PosCounter writeArrayStart(size_t num){
        auto ac=PosCounter(num);
        do { // is this really a good idea? especially wrt. aligment and memory mapping?
            ubyte part = num & 127;
            if (num > 0b01111111) part |= 0b10000000;
            num >>= 7;
            writer_(part);
        } while (num != 0);
        return ac;
    }
    /// start of a dictionary
    override void writeDictStart(size_t num,bool stringKeys=false) {
        auto ac=PosCounter(num);
        do { // is this really a good idea? especially wrt. aligment and memory mapping?
            ubyte part = num & 127;
            if (num > 0b01111111) part |= 0b10000000;
            num >>= 7;
            writer_(part);
        } while (num != 0);
        return ac;
    }
    /// writes an Object
    void writeObject(ClassMetaInfo *metaInfo,FieldMetaInfo *field, size_t objId,
        lazy void delegate() realWrite, Object o){
        realWrite();
    }
    /// write ObjectProxy
    void writeObjectProxy(ClassMetaInfo *metaInfo,FieldMetaInfo *field, size_t objId, Object o){
        assert(0,"unimplemented");
    }
    /// write Struct
    void writeStruct(ClassMetaInfo *metaInfo,FieldMetaInfo *field, size_t objId,
        lazy void delegate() realWrite){
        realWrite();
    }
    /// writes a core type
    void writeCoreType(ClassMetaInfo *metaInfo,FieldMetaInfo *field, size_t objId,
        lazy void delegate() realWrite){
        realWrite();
    }+/
    
}

/// read handlers build on the top of tango Reader (could be faster)
final class BinaryReadHandlers:ReadHandlers{
    protected Reader       reader;
    
    this (Reader reader)
    {
        this.reader=reader;
        setCoreHandlersFrom_basicRead();
    }
    
    /// returns if the current protocol is binary or not
    bool binary(){
        return true;
    }
    /// writes a basic
    void basicRead(T)(ref T t){
        static if (is(T==ifloat)){
            float f;
            reader(f);
            t=cast(T)(1i*f);
        } else static if (is(T==idouble)){
            double d;
            reader(d);
            t=cast(T)(1i*d);
        } else static if (is(T==ireal)){
            real r;
            reader(r);
            t=cast(T)(1i*r);
        } else static if (is(T==cfloat)){
            float f1,f2;
            reader(f1);
            reader(f2);
            t=cast(T)(f1+1i*f2);
        } else static if (is(T==cdouble)){
            double f1,f2;
            reader(f1);
            reader(f2);
            t=cast(T)(f1+1i*f2);
        } else static if (is(T==creal)){
            real f1,f2;
            reader(f1);
            reader(f2);
            t=cast(T)(f1+1i*f2);
        } else {
            reader(t);
        }
    }
    mixin(coreHandlerSetFromTemplateMixinStr("basicRead"));

    /// reads a raw sequence of bytes
    ubyte[] rawRead(size_t amount){
        ubyte[] data;
        basicRead(data);
        return data;
    }
    /// reads a raw string
    char[] rawReadStr(size_t amount){
        char[] data;
        basicRead(data);
        return data;
    }
/+    override PosCounter readArrayStart(){
        ulong res = 0;
        bool cont = true;
        for (int i = 0; cont; ++i) {
            ubyte part;
            reader(part);
            //Stdout.formatln(`part: {}`, part);
            cont = (part & 0b10000000) != 0;
            res |= (part & 0b01111111) << (i * 7);
        }
        return PosCounter(cast(size_t)res);
    }
    /// writes out a dictionary prepended by its compressed length
    final class DictionaryCmptLengthReader:ReadHandlers.DictionaryReader{
        size_t pos,length;
        /// start of a dictionary
        override void readDictStart(size_t length) {
            assert(pos==length,"recursive use not supported");
        }
        /// returns true if there is a next entry
        override bool nextEntry() {
            if (pos!=length){
                ++pos;
                return true;
            }
            return false;
        }
        /// middle of entry (between key and value)
        override void readEntryMid() {}
        /// hint on the size of the dictionary
        override size_t sizeHint(){ length; }
        this() { super(); }
    }
    /// object that helps the writing of an associative array
    override DictionaryCmptLengthReader dictionaryReader(){
        return new DictionaryCmptLengthReader();
    }+/
}


/// write handlers for formatted writing
final class FormattedWriteHandlers: WriteHandlers{
    FormatOutput!(char) writer;
    this(FormatOutput!(char) w){
        writer=w;
        setCoreHandlersFrom_basicWrite();
    }
    /// writes a basic type (basic types are atomic types or strings)
    void basicWrite(T)(ref T t){
        static assert(!(is(T==char) || is(T==wchar) || is(T==dchar)),
            "single character writes not supported, only string writes");
        static if (is(T==char[])||is(T==wchar[])||is(T==dchar[])){
            writer("\"");
            writer(escape(t));//escape(t, cast(void delegate(T))&writer.stream.write);
            writer("\"");
        } else static if (is(T==ubyte[])){
            writer("\"");
            writer(encode(t));
            writer("\"");
        } else static if (isBasicCoreType!(T)){
            writer(t);
        } else {
            static assert(0,"invalid basic type "~T.stringof);
        }
    }
    
    mixin(coreHandlerSetFromTemplateMixinStr("basicWrite"));

    /// returns if the current protocol is binary or not
    bool binary(){
        return false;
    }
    /// writes a raw sequence of bytes
    void rawWrite(ubyte[] data){
        basicWrite(data); // should encode it in base 64 or something like it
    }
    /// writes a raw string
    void rawWriteStr(char[]data){
        writer(data);
    }
}

/// read handlers build on the top of tango Reader (could be faster)
final class FormattedReadHandlers(T):ReadHandlers{
    TextParser!(T)       reader;
    
    this (TextParser!(T) reader)
    {
        this.reader=reader;
        setCoreHandlersFrom_basicRead();
    }
    
    /// returns if the current protocol is binary or not
    bool binary(){
        return false;
    }
    /// reads a basic type
    void basicRead(U)(ref U t){
        static assert(isCoreType!(U),"invalid non core type "~U.stringof);
        static if (is(U==ubyte[])){
            T[]str;
            reader(str);
            t=decode(str);
        } else {
            reader(t);
        }
    }
    
    mixin(coreHandlerSetFromTemplateMixinStr("basicRead"));

    /// reads a raw sequence of bytes
    ubyte[] rawRead(size_t amount){
        ubyte[] data;
        basicRead(data);
        return data;
    }
    /// reads a raw string
    T[] rawReadStr(size_t amount){
        return reader.readNCodePoints(amount);
    }
    /// skips the given string
    bool skipStr(T[] str){
        return reader.skipString(str);
    }
/+    override PosCounter readArrayStart(){
        ulong res = 0;
        bool cont = true;
        for (int i = 0; cont; ++i) {
            ubyte part;
            reader(part);
            //Stdout.formatln(`part: {}`, part);
            cont = (part & 0b10000000) != 0;
            res |= (part & 0b01111111) << (i * 7);
        }
        return PosCounter(cast(size_t)res);
    }
    /// writes out a dictionary prepended by its compressed length
    final class DictionaryCmptLengthReader:ReadHandlers.DictionaryReader{
        size_t pos,length;
        /// start of a dictionary
        override void readDictStart(size_t length) {
            assert(pos==length,"recursive use not supported");
        }
        /// returns true if there is a next entry
        override bool nextEntry() {
            if (pos!=length){
                ++pos;
                return true;
            }
            return false;
        }
        /// middle of entry (between key and value)
        override void readEntryMid() {}
        /// hint on the size of the dictionary
        override size_t sizeHint(){ length; }
        this() { super(); }
    }
    /// object that helps the writing of an associative array
    override DictionaryCmptLengthReader dictionaryReader(){
        return new DictionaryCmptLengthReader();
    }+/
}
